#!/usr/bin/env python3
"""
This server is used to control a Django server deployed through uWSGI. It can
send commands to the uWSGI server through it's Master FIFO, allowing the Django
server to effectively restart itself and manage it's deployment configuration by
querying this server. It can also run management commands on the Django server,
allowing it to do things like making and applying migrations by querying this
server.

The HMTL interface for this server uses Bootstrap and jQuery, so these two
libraries must be installed in the :attr:`STATIC_ROOT` folder (as defined in the
settings file for the Django server being controlled) for the HTML pages to
render correctly

This server reads from the following environment variables:

.. envvar:: DJANGO_SETTINGS_MODULE
    The settings file of the Django server being controlled. The file must
    define the variables :attr:`STATIC_ROOT`, the folder in which static files
    for the project are stored, and :attr:`BASE_DIR`, the root directory of the
    Django project for the server being controlled

.. envvar:: CITYFARM_API_MASTER_FIFO
    The uWSGI Master FIFO for the Django server being controlled.

Both of these variables are defined in the :obj:`.env` file generated by
:program:`setup_environment.sh`.
"""

###################
# Imports & Setup #
###################

import os
import enum
import select
import importlib
import itertools
import subprocess
from functools import wraps
from flask import Flask, request, Response, jsonify, g

django_settings = importlib.import_module(os.environ['DJANGO_SETTINGS_MODULE'])
app = Flask(__name__, static_folder=django_settings.STATIC_ROOT)
app.config.fifo_path = os.environ['CITYFARM_API_MASTER_FIFO']
app.config.manager_path = os.path.join(django_settings.BASE_DIR, 'manage.py')

# Debugging Support
if os.environ['CITYFARM_API_SERVER_MODE'] == 'development':
    app.debug = True
    from werkzeug import DebuggedApplication
    wsgi_app = DebuggedApplication(app)
else:
    wsgi_app = app

#############
# Constants #
#############

HTML_MIMETYPE = 'text/html'
JSON_MIMETYPE = 'application/json'

##############
# Exceptions #
##############

class InvalidFilePath(Exception):
    """
    A base exception type for errors in which an invalid filepath is received.
    Subclasses of this Exception must define the :attr:`message` attribute.
    """
    status_code = 500
    def __init__(self, filepath):
        super().__init__()
        self.filepath = filepath

class InvalidFifoPath(InvalidFilePath):
    """
    This exception should be thrown if this server fails to find the Master FIFO
    of the Django server to be controlled.
    """
    @property
    def message(self):
        return 'FIFO file "%s" does not exist' % self.filepath

class InvalidManagerPath(InvalidFilePath):
    """
    This exception should be thrown if this serer fails to find the manage.py
    file of the Django server to be controlled.
    """
    @property
    def message(self):
        return 'manage.py file "%s" does not exist' % self.filepath

@app.errorhandler(InvalidFilePath)
def handle_invalid_file_path(error):
    response = Response(error.message)
    response.status_code = error.status_code
    return response

###################
# Command Classes #
###################

def command_index():
    if not hasattr(g, 'command_index'):
        g.command_index = 0
    g.command_index += 1
    return g.command_index

class CommandSet:
    html_head = """<html>
  <head>
    <script src="static/jquery/js/jquery.min.js"></script>
    <link rel="stylesheet" href="static/bootstrap/css/bootstrap.min.css">
    <link rel="stylesheet" href="static/bootstrap/css/bootstrap-theme.min.css">
    <script src="static/bootstrap/js/bootstrap.min.js"></script>
  </head>
  <body>
    <div class="container">
      <div class="panel-group" id="accordion" role="tablist">"""
    html_tail = """
      </div>
    </div>
    <script type="text/javascript">
        $("#collapse1").addClass("in");
    </script>
  </body>
</html>"""
    def __init__(self, *commands):
        for command in commands:
            if not isinstance(command, Command):
                raise TypeError("CommandSet can only hold Command instances")
        self.commands = list(commands)
    def to_json(self):
        return [command.to_json() for command in self.commands]
    def to_html(self):
        yield self.html_head
        for command in self.commands:
            for line in command.to_html():
                yield line
        yield self.html_tail
    def to_json_response(self):
        return jsonify(self.to_json())
    def to_html_response(self):
        return Response(self.to_html(), mimetype='text/html')
    def to_response(self):
        json_match_quality = request.accept_mimetypes[JSON_MIMETYPE]
        html_match_quality = request.accept_mimetypes[HTML_MIMETYPE]
        if json_match_quality > html_match_quality:
            return self.to_json_response()
        else:
            return self.to_html_response()

class Command:
    title = "Unnamed Command"
    def __init__(self):
        self.command_index = command_index()
    _html_head = """
<div class="panel" id="panel{index}">
  <div class="panel panel-heading" role="tab">
    <h4 class="panel-title">
      <a data-toggle="collapse" data-parent="#accordion" href="#collapse{index}">
        {title}
      </a>
    </h4>
  </div>
  <div id="collapse{index}" class="panel-collapse collapse" role="tabpanel">
    <div class="panel-body">
<pre class="pre-scrollable">"""
    @property
    def html_head(self):
        return self._html_head.format(index=self.command_index,
                title=self.title)
    _html_tail = """
</pre>
    </div class="panel-body">
  </div>
  <script type="text/javascript">
    $("#panel{index}").addClass("{panel_class}");
  </script>
</div>"""
    @property
    def html_tail(self):
        if hasattr(self, "returncode"):
            if self.returncode == 0:
                panel_class = "panel-success"
            else:
                panel_class = "panel-warning"
        else:
            panel_class = "panel-default"
        return self._html_tail.format(index=self.command_index,
                panel_class=panel_class)
    def to_json(self):
        raise NotImplementedError()
    def to_html(self):
        raise NotImplementedError()

class StreamItem(str):
    def __new__(cls, text, is_error=False):
        obj = super().__new__(cls, text)
        obj.is_error = is_error
        return obj
    def to_json(self):
        return self
    def to_html(self):
        if self.is_error:
            return '<font color="red">{}</font>'.format(self)
        else:
            return self

def ManagerCommand(title, *args):
    _title = title
    class Inner(Command):
        title = _title
        command = (app.config.manager_path,) + args
        def __init__(self):
            manager_path = app.config.manager_path
            if not os.path.isfile(manager_path):
                raise InvalidManagerPath(manager_path)
            super().__init__()
        def run(self):
            proc = subprocess.Popen(
                    ' '.join(self.command),
                    shell=True,
                    stdout=subprocess.PIPE,
                    stderr=subprocess.PIPE,
            )
            while True:
                reads = [proc.stdout.fileno(), proc.stderr.fileno()]
                ret = select.select(reads, [], [])
                for fd in ret[0]:
                    if fd == proc.stdout.fileno():
                        item = b''.join(proc.stdout.readlines()).decode('ascii')
                        yield StreamItem(item)
                    if fd == proc.stderr.fileno():
                        item = b''.join(proc.stderr.readlines()).decode('ascii')
                        yield StreamItem(item, True)
                if proc.poll() != None:
                    self.returncode = proc.returncode
                    break
        def to_json(self):
            log = []
            error = []
            for line in self.run():
                log.append(line)
                if line.is_error:
                    error.append(line)
            response = {}
            response['log'] = ''.join(log)
            repsonse['error'] = ''.join(error)
            response['returncode'] = self.returncode
        def to_html(self):
            yield self.html_head
            for line in self.run():
                yield line.to_html()
            yield self.html_tail
    return Inner

MakeMigrations = ManagerCommand("Make Migrations", "makemigrations")
Migrate = ManagerCommand("Migrate", "migrate")

def FifoCommand(title, fifo_command):
    _title = title
    class Inner(Command):
        title = _title
        def __init__(self):
            fifo_path = app.config.fifo_path
            if not os.path.isfile(fifo_path):
                raise InvalidFifoPath(fifo_path)
            super().__init__()
        def run(self):
            with open(app.config.fifo_path, 'a') as f:
                f.write(fifo_command)
        def to_json(self):
            return "Success"
        def to_html(self):
            yield self.html_head
            yield 'Wrote "{}" to Master FIFO'.format(fifo_command)
            yield self.html_tail
    return Inner

ReloadWorkers = FifoCommand("Reload Workers", "c")

################
# Flask Routes #
################

@app.route('/restart')
def restart():
    command_set = CommandSet(MakeMigrations(), Migrate(), ReloadWorkers())
    return command_set.to_response()

if __name__ == '__main__':
    app.run(host='127.0.0.1', port=8080)
