#!/usr/bin/env python
"""
This module defines a set of commands (either uWSGI Master FIFO commands or
:program:`manage.py` subcommands) that can be run.

This module reads from the following environment variables:

.. envvar:: CITYFARM_API_MASTER_FIFO
    The uWSGI Master FIFO for the parent Django project.

.. envvar:: DJANGO_SETTINGS_MODULE
    The settings module of the parent Django project. The module must define the
    variable :attr:`BASE_DIR` to be the filepath of the root directory of the
    Django project because this module uses it to determine the filepath of the
    :program:`manage.py` file to call.

Both of these variable are defined in the :obj:`.env` file generated by
:program:`setup_environment.sh`.
"""

import os
import select
import importlib
import subprocess
from control.exceptions import InvalidFifoPath, InvalidManagerPath

fifo_path = os.environ['CITYFARM_API_MASTER_FIFO']
django_settings = importlib.import_module(os.environ['DJANGO_SETTINGS_MODULE'])
manager_path = os.path.join(django_settings.BASE_DIR, 'manage.py')


###################
# Command Classes #
###################

class OutputItem(str):
    """
    A line or set of lines in the output of a command. An
    :class:`~control.command.OutputItem` is just a :class:`str` with an extra
    attribute :attr:`is_error` that reflects whether or not this item resulted
    from an error in it's source program.
    """
    def __new__(cls, text, is_error=False):
        obj = super().__new__(cls, text)
        obj.is_error = is_error
        return obj


class Command:
    """
    A base class for all commands in this module. Subclasses of
    :class:`~control.commands.Command` should define an attribute
    :attr:`returncode` after their :func:`~control.commands.Command.run`
    function has been called reflecting the result of the command being run.
    """
    #: The title of this command
    title = 'Unnamed Command'

    def run(self):
        """
        Runs this command and generates an :class:`~control.commands.OutputItem`
        instance for each line in the output of the command. Subclasses of
        :class:`~control.commands.Command` must implement
        :fun:`~control.commands.Command.run`.
        """
        raise NotImplementedError()


def FifoCommand(title, fifo_command):
    """
    Returns a command class that writes a single command to the Master FIFO.

    :param str title: The title of the command
    :param str fifo_command: The command to write to the Master FIFO
    """
    _title = title  # Scoping is weird

    class Inner(Command):
        title = _title

        def check(self):
            if not os.path.isfile(fifo_path):
                raise InvalidFifoPath(fifo_path)

        def run(self):
            self.check()
            with open(fifo_path, 'a') as f:
                f.write(fifo_command)
            message = 'Wrote "{}" to "{}"'.format(fifo_command, fifo_path)
            yield OutputItem(message)
            self.returncode = 0
    return Inner
ReloadWorkers = FifoCommand("Reload Workers", "c")


def ManagerCommand(title, *args):
    """
    Returns a command class that calls a subcommand of the Django project's
    :program:`manage.py` file.

    :param str title: The title of the command
    :param *args: The arguments to pass to :program:`manage.py`
    """
    _title = title  # Scoping is weird
    _args = args  # Scoping is weird

    class Inner(Command):
        title = _title
        args = ('python', manager_path) + _args

        def check(self):
            if not os.path.isfile(manager_path):
                raise InvalidManagerPath(manager_path)

        def run(self):
            self.check()
            proc = subprocess.Popen(
                ' '.join(self.args),
                shell=True,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
            )
            while True:
                reads = [proc.stdout.fileno(), proc.stderr.fileno()]
                ret = select.select(reads, [], [])
                for fd in ret[0]:
                    if fd == proc.stdout.fileno():
                        item = b''.join(proc.stdout.readlines()).decode('ascii')
                        yield OutputItem(item)
                    if fd == proc.stderr.fileno():
                        item = b''.join(proc.stderr.readlines()).decode('ascii')
                        yield OutputItem(item, True)
                if proc.poll() is not None:
                    self.returncode = proc.returncode
                    break
    return Inner
MakeMigrations = ManagerCommand("Make Migrations", "makemigrations")
Migrate = ManagerCommand("Migrate", "migrate")
